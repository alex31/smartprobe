

             _______           _____                   
            |__   __|         |  __ \                  
               | |      ___   | |  | |    ___          
               | |     / _ \  | |  | |   / _ \         
               | |    | (_) | | |__| |  | (_) |        
               |_|     \___/  |_____/    \___/         


A TESTER :
     * le passage en paramètres de :
       + choix au niveau du log :  valeurs brutes de l'IMU ou valeurs sortant de l'AHRS

  
A CODER :

     * timestamp avec une decimale de plus si freq d'acquisition près de la milliseconde ou en dessous

A AMELIORER :

   ° fix
	* tester si vsnprintf est bien reentrant
	* proteger le dictionaire des config par un mutex (accesseur etc)
	* lecture de conf : predimensionner les std::string, buffer[80] ??
	* utiliser le fork chibios d'ardupilot pour voir si le fix I²C evite des pb
	* porter confFile.cpp sous linux pour le debugger avec valgrind pour trouver les pb mémoire
	  (double free ?)	

	* recoder la partie  FCNTL_WRITE de sdLog.c pour factoriser le code
	* tester presence du dirty bit : indiquer par led et syslog
	* porter fsck.vfat de linux à MCU pour permettre un fsck automatique si dirty bit au demarrage




GRANDES LIGNES : 

	  
   ° écrire des modules
        * syslog periodique de la charge de calcul
	
	* ahrs
	  ° qui donne 3 angles si la donnée heading est disponible :
   

	* watchdog IWDG -> test au boot, si il y a eu hardfault -> log
	
	* recup de données gps -> ref horaire, calcul du cap, choix du format
	  dans le fichier de conf :
	  ø nmea ou trame pprz (ou autre ?)
	  
	* calcul d'un vecteur vent dans le repaire terrestre si l'ahrs est
	  en mode 3 angles et que l'autopilote fournit un vecteur vitesse en 3D
	  
	* code pour les leds :
	  ° utiliser un module WS2812 : choix du timer, DMA
	  ° blink verte  : heartbeat
	  ° blink bleu :   usb_storage
	  ° uniquement en cas d'erreur grave :
	  °  blink jaune : pb sdcard
	  °  blink rouge : pb capteur
	  
        * quand on teste le 5V, tester aussi le 3.3V en utilisant la reference interne

	* si le fichier de log fini en .txt : log texte, sinon : log binaire
	    
	* access en USB2 pour accelerer l'acces USB Storage


   ° integration de librairies externes
	* module SerialMessage
	* micro python pour coder du comportement via le fichier de conf
	  sans avoir à reflasher ?
	* quand le projet devra être distribué : mettre toutes les
	  dépendences externes en sous modules git
	


             _____     __  __    ___          
            |  __ \   |  \/  |  / _ \         
            | |  | |  | \  / | | |_| |        
            | |  | |  | |\/| | |  _  |        
            | |__| |  | |  | | | | | |        
            |_____/   |_|  |_| |_| |_|        
                    _                                                     
                   | |                                                    
             ___   | |_    _ __    ___    __ _   _ __ ___    ___          
            / __|  | __|  | '__|  / _ \  / _` | | '_ ` _ \  / __|         
            \__ \  \ |_   | |    |  __/ | (_| | | | | | | | \__ \         
            |___/   \__|  |_|     \___|  \__,_| |_| |_| |_| |___/         



#define STM32_ADC_ADC1_DMA_STREAM           STM32_DMA_STREAM_ID(2, 4)
#define STM32_SDC_SDMMC1_DMA_STREAM         STM32_DMA_STREAM_ID(2, 6)
#define STM32_SPI_SPI1_RX_DMA_STREAM        STM32_DMA_STREAM_ID(2, 0)
#define STM32_SPI_SPI1_TX_DMA_STREAM        STM32_DMA_STREAM_ID(2, 3)
#define STM32_I2C_I2C2_RX_DMA_STREAM        STM32_DMA_STREAM_ID(1, 3)
#define STM32_I2C_I2C2_TX_DMA_STREAM        STM32_DMA_STREAM_ID(1, 7)
#define STM32_I2C_I2C4_RX_DMA_STREAM        STM32_DMA_STREAM_ID(1, 2)
#define STM32_I2C_I2C4_TX_DMA_STREAM        STM32_DMA_STREAM_ID(1, 5)

